# 前提
+ 以下策略以天为计算单位，每一天仅考虑当天的已有资源和虚拟机请求

# 名词定义
+ **资源综合值**：cpu与memory的欧氏距离的平方
+ **综合开销**：硬件成本 + α * 预计剩余运行天数 * 日常成本 *(α作为调节参数，0 < α <= 1)*
+ **资源利用率**：已分配资源综合值 / 总资源综合值（仅考虑服务器整体，无关内部节点）
+ **排序既定策略**：资源利用率或服务器负载

# 迁移策略
+ **约束**：迁移总量不得超过当前虚拟机存量的*5/1000*
+ **输入**：已分配资源的服务器（资源稀疏分布），资源分配映射
+ **输出**：已分配资源的服务器，资源迁移映射
+ **解释**：目的是将随机稀疏分布的资源重新调整为密集分布，尽量增加空载服务器数量；力求节点负载均衡
+ **策略**：
```
将输入的服务器按照既定策略递增排序，假设长度为n
遍历服务器0到n-1，记当前服务器索引i：
    遍历服务器i的两个节点中的所有虚拟机资源，记当前虚拟机为vm：
        若vm在删除请求中：
            跳过vm，继续处理下一个虚拟机
        遍历服务器n-1到i+1，记当前服务器索引j：
            若虚拟机vm占用双节点：
                尝试将虚拟机v放入服务器j
            若虚拟机vm占用单节点：
                尝试将虚拟机vm放入服务器j的负载(资源综合值)较低的节点
            若成功：
                记录资源迁移映射和已迁移虚拟机总量
                若迁移总量达到约束限制：
                    退出该策略函数，返回相关信息
                重新插入受影响的服务器
                跳出循环j，继续处理下一资源
```

# 放置策略
+ **输入**：已分配资源的服务器，虚拟机增添请求
+ **输出**：已分配资源的服务器，剩余虚拟机增添请求（无法分配入服务器的），资源分配映射
+ **解释**：虚拟机放置的目标是最大化物理服务器的资源利用率，即尽可能放置更多虚拟机请求；力求节点负载均衡
+ **策略**：
```
将输入的服务器按既定策略递减排序
遍历所有输入的虚拟机请求，对每一个请求：
    遍历输入的服务器，对每一个服务器：
        若请求的虚拟机占用双节点：
            尝试将该请求放入该服务器
        若请求的虚拟机占用单节点：
            尝试将该请求放入该服务器的负载较低的节点
        若成功：
            记录资源分配映射
            重新插入受影响的服务器
            跳出服务器循环，处理下一个请求
    若无法放入任何服务器，将该请求加入需要输出的虚拟机请求列表
输出无法分配的剩余请求和资源分配映射
```

# 购买策略
+ **输入**：未得到分配的虚拟机请求，可选购服务器
+ **输出**：购买的服务器，资源分配映射
+ **解释**：虚拟机购买的目标是最小化购买的服务器的综合开销，条件是放置所有虚拟机请求
+ **策略**：
```
计算输入虚拟机请求的总所需资源（尽量均分单节点虚拟机至两组中）
将可选购服务器按照综合开销递增排序
遍历所有可选购服务器，对于每一个服务器：
    如果该服务器可以装载所有的请求：
        购买该服务器，将所有请求分配至该服务器
        返回输出
若没有任何服务器可以一次性装载所有资源：
    将输入请求随机二分，并分别递归调用此策略函数，保存返回值
    合并两个返回值，组合成最终输出
    返回输出
```

# 删除策略
+ **解释**：处理当天所有的删除请求，输出结果为稀疏分布的服务器内部资源。

# 代码数据结构
```Python
# 可采购的服务器类型（数量：int[1, 100]）
ALL_PMS = {服务器型号:
    {"size": Vector([CPU核数, 内存大小]),
     "cost": Vector([硬件成本, 每日能耗成本])}
, ...}

# 供售卖的虚拟机类型（数量：int[1, 1000]）
ALL_VMS = {虚拟机型号:
    {"size": Vector([CPU核数, 内存大小]),
     "isDual": 是否双节点}
, ...}

# 以天为单位的用户请求序列（天数：int[1, 1000]，请求总数<10**5）
REQS = [
    {"add": [(虚拟机id, 虚拟机型号), ...],
     "del": {虚拟机id, ...}}
, ...]

# 已拥有服务器
OWNED_PMS = [
    {"pmType": 服务器型号,
     "vms": {虚拟机id, ...},
     "A": Vector([剩余cpu, 剩余momory]),
     "B": Vector([剩余cpu, 剩余momory])}
, ...]

# 已分配的存量虚拟机
STOCK_VMS = {虚拟机id:
    {"vmType": 虚拟机型号,
     "pmId": 所在服务器id,
     "node": 所在服务器节点("A"/"B"/None)}
, ...}

```

# 优化方向
+ 尝试serverLoad等其他既定策略，研究论文
+ 奇偶并行？
